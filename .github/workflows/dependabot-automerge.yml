# Automerge Dependabot PRs that have the "automerge" label after required checks pass.
# Mirrors secret-manager-controller pattern: schedule + workflow_dispatch, wait for CI jobs, squash merge.
on:
  schedule:
    - cron: "0 */6 * * *"
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  automerge:
    name: Automerge Dependabot PRs
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Find and process Dependabot PRs
        uses: actions/github-script@v8
        with:
          script: |
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
            });

            const dependabotPRs = prs.filter(pr =>
              pr.user.login === 'dependabot[bot]' &&
              pr.labels.some(label => label.name === 'automerge')
            );

            console.log(`Found ${dependabotPRs.length} Dependabot PR(s) with automerge label`);

            if (dependabotPRs.length === 0) {
              console.log('‚úÖ No PRs to process');
              return;
            }

            const requiredStatusChecks = ['Lint', 'Run tests'];
            const maxWaitTime = 30 * 60 * 1000;
            const checkInterval = 30 * 1000;

            for (const pr of dependabotPRs) {
              console.log(`\nüìã Processing PR #${pr.number}: ${pr.title}`);

              const { data: prDetails } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
              });

              if (prDetails.mergeable === false) {
                console.log(`‚ö†Ô∏è  PR #${pr.number} is not mergeable (may have conflicts)`);
                continue;
              }

              const startTime = Date.now();
              let checksPassed = false;

              while (Date.now() - startTime < maxWaitTime) {
                const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: pr.head.sha,
                });

                const { data: checks } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: pr.head.sha,
                });

                const allStatuses = [
                  ...statuses.map(s => ({ name: s.context, state: s.state })),
                  ...checks.check_runs.map(c => ({ name: c.name, state: c.status === 'completed' ? c.conclusion : c.status })),
                ];

                const requiredChecks = requiredStatusChecks.map(name => {
                  const status = allStatuses.find(s => s.name === name || s.name.includes(name));
                  return { name, status };
                });

                const allPassed = requiredChecks.every(
                  check => check.status && (check.status.state === 'success' || check.status.state === 'completed')
                );
                const anyFailed = requiredChecks.some(
                  check => check.status && (check.status.state === 'failure' || check.status.state === 'failed')
                );

                if (allPassed) {
                  console.log(`‚úÖ All required checks passed for PR #${pr.number}`);
                  checksPassed = true;
                  break;
                }

                if (anyFailed) {
                  console.log(`‚ùå One or more required checks failed for PR #${pr.number}`);
                  break;
                }

                console.log(`‚è≥ Waiting for status checks for PR #${pr.number}...`);
                await new Promise(resolve => setTimeout(resolve, checkInterval));
              }

              if (!checksPassed) {
                console.log(`‚è±Ô∏è  Timeout or checks failed for PR #${pr.number}, skipping merge`);
                continue;
              }

              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  merge_method: 'squash',
                  commit_title: `${pr.title} (#${pr.number})`,
                  commit_message: `Automerge: ${pr.body || ''}`,
                });
                console.log(`‚úÖ PR #${pr.number} merged successfully`);
              } catch (error) {
                if (error.status === 405) {
                  console.log(`‚ö†Ô∏è  PR #${pr.number} cannot be merged (may require review or have conflicts)`);
                } else {
                  console.error(`‚ùå Error merging PR #${pr.number}:`, error.message);
                }
              }
            }
